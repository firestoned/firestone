// Auto-generated CLI module - generated by firestone
use clap::{Parser, Subcommand};
use serde_json;
use std::sync::Arc;

use crate::apis::configuration::Configuration;

#[derive(clap::ValueEnum, Clone, Debug)]
enum AddrtypeEnum {
WORK,
HOME,
}
// Context for API client - similar to Python's ctx_obj
pub struct ApiContext {
    pub api_client: Arc<Configuration>,
}

#[derive(Subcommand, Debug)]
pub enum AddressbookCommands {
    /// Create a new address in this addressbook, a new address key will be created.
    Create(CreateArgs),
    /// List all addresses in this addressbook.
    List(ListArgs),
    /// Delete an address from this addressbook.
    Delete(DeleteArgs),
    /// Get a specific address from this addressbook.
    Get(GetArgs),
    /// Update an existing address in this addressbook, with the given address key.
    Update(UpdateArgs),
    }

#[derive(Parser, Debug)]
pub struct CreateArgs {
/// A unique identifier for an addressbook entry.
    #[arg(long)]
    pub address_key: Option<String>,
    /// The address type, e.g. work or home
    #[arg(long, value_enum)]
    pub addrtype: AddrtypeEnum,
    /// The city of this address
    #[arg(long)]
    pub city: String,
    /// The country of this address
    #[arg(long)]
    pub country: String,
    /// Address is valid or not
    #[arg(long, action = clap::ArgAction::SetTrue)]
    pub is_valid: Option<bool>,
    /// A list of people's names living there
    #[arg(long)]
    pub people: Option<Vec<String>>,
    /// This is a person object that lives at this address.
    #[arg(long)]
    pub person: Option<String>,
    /// The state of this address
    #[arg(long)]
    pub state: String,
    /// The street and civic number of this address
    #[arg(long)]
    pub street: String,
    }

#[derive(Parser, Debug)]
pub struct ListArgs {
/// Filter by city name
    #[arg(long)]
    pub city: Option<String>,
    /// Limit the number of responses back
    #[arg(long)]
    pub limit: Option<i64>,
    /// The offset to start returning resources
    #[arg(long)]
    pub offset: Option<i64>,
    }

#[derive(Parser, Debug)]
pub struct DeleteArgs {
/// 
    pub address_key: String,
    }

#[derive(Parser, Debug)]
pub struct GetArgs {
/// 
    pub address_key: String,
    /// Filter by city name
    #[arg(long)]
    pub city: Option<String>,
    }

#[derive(Parser, Debug)]
pub struct UpdateArgs {
/// A unique identifier for an addressbook entry.
    pub address_key: String,
    /// The address type, e.g. work or home
    #[arg(long, value_enum)]
    pub addrtype: Option<AddrtypeEnum>,
    /// The city of this address
    #[arg(long)]
    pub city: Option<String>,
    /// The country of this address
    #[arg(long)]
    pub country: Option<String>,
    /// Address is valid or not
    #[arg(long, action = clap::ArgAction::SetTrue)]
    pub is_valid: Option<bool>,
    /// A list of people's names living there
    #[arg(long)]
    pub people: Option<Vec<String>>,
    /// This is a person object that lives at this address.
    #[arg(long)]
    pub person: Option<String>,
    /// The state of this address
    #[arg(long)]
    pub state: Option<String>,
    /// The street and civic number of this address
    #[arg(long)]
    pub street: Option<String>,
    }

pub async fn handle_addressbook_command(
    ctx: &ApiContext,
    cmd: &AddressbookCommands,
) -> Result<(), Box<dyn std::error::Error>> {
    match cmd {
AddressbookCommands::Create(args) => {
            handle_addressbook_post(ctx, args).await
        },
AddressbookCommands::List(args) => {
            handle_addressbook_get(ctx, args).await
        },
AddressbookCommands::Delete(args) => {
            handle_addressbook_address_key_delete(ctx, args).await
        },
AddressbookCommands::Get(args) => {
            handle_addressbook_address_key_get(ctx, args).await
        },
AddressbookCommands::Update(args) => {
            handle_addressbook_address_key_put(ctx, args).await
        },
}
}

async fn handle_addressbook_post(
    ctx: &ApiContext,
    args: &CreateArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build request body for create operation
    let req_body = crate::models::CreateAddressbook {
        address_key: args.address_key.as_ref().map(|s| Some(serde_json::Value::String(s.clone()))),
        addrtype: match args.addrtype {
            AddrtypeEnum::WORK => crate::models::create_addressbook::Addrtype::Work,
            AddrtypeEnum::HOME => crate::models::create_addressbook::Addrtype::Home,
            },
        city: args.city.clone(),
        country: args.country.clone(),
        is_valid: args.is_valid,
        people: args.people.clone(),
        person: args.person.as_ref().and_then(|s| serde_json::from_str::<crate::models::Person>(s).ok()).map(|p| Box::new(p)),
        state: args.state.clone(),
        street: args.street.clone(),
        };
    
    // Extract query parameters (limit, offset) if present
    let limit = None::<i32>;
    let offset = None::<i32>;
    let resp = crate::apis::addressbook_api::addressbook_post(&ctx.api_client, req_body, limit, offset).await?;
    Ok(())
}

async fn handle_addressbook_get(
    ctx: &ApiContext,
    args: &ListArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters - openapi-generator functions take individual Option parameters
    let city_param = args.city.as_ref().map(|s| s.as_str());
    let limit_param = None::<i32>;
    let offset_param = None::<i32>;
    let resp = crate::apis::addressbook_api::addressbook_get(&ctx.api_client, city_param, limit_param, offset_param).await?;
    // Output response as JSON
    let json_output = serde_json::to_string_pretty(&resp)?;
    println!("{}", json_output);
    Ok(())
}

async fn handle_addressbook_address_key_delete(
    ctx: &ApiContext,
    args: &DeleteArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters for instance operations
    let city_param = None::<&str>;
    // DELETE operations may return empty responses (204 No Content)
    // Handle gracefully without panicking on content type mismatches
    let resp_result = crate::apis::addressbook_api::addressbook_address_key_delete(&ctx.api_client, &args.address_key).await;
    match resp_result {
        Ok(data) => {
            // If we got JSON data, serialize and print it
            let json_output = serde_json::to_string_pretty(&data)?;
            println!("{}", json_output);
        },
        Err(crate::apis::Error::Serde(e)) => {
            // Check if this is a content type mismatch (empty response)
            let error_msg = e.to_string();
            if error_msg.contains("content type") || error_msg.contains("application/octet-stream") || error_msg.contains("cannot be converted") {
                // Empty response is OK for DELETE - operation succeeded
                // Output success JSON
                println!("{}", r#"{"status": "deleted"}"#);
            } else {
                // Real serialization error, propagate it
                return Err(Box::new(e));
            }
        },
        Err(e) => {
            // Other errors (network, HTTP errors, etc.) - propagate
            return Err(Box::new(e));
        }
    }
    Ok(())
}

async fn handle_addressbook_address_key_get(
    ctx: &ApiContext,
    args: &GetArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters for instance operations
    let city_param = args.city.as_ref().map(|s| s.as_str());
    let resp = crate::apis::addressbook_api::addressbook_address_key_get(&ctx.api_client, &args.address_key, city_param).await?;
    // Output response as JSON
    let json_output = serde_json::to_string_pretty(&resp)?;
    println!("{}", json_output);
    Ok(())
}

async fn handle_addressbook_address_key_put(
    ctx: &ApiContext,
    args: &UpdateArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build request body for update operation
    let req_body = crate::models::UpdateAddressbook {
        address_key: None,
        addrtype: args.addrtype.as_ref().map(|e| match e {
            AddrtypeEnum::WORK => crate::models::update_addressbook::Addrtype::Work,
            AddrtypeEnum::HOME => crate::models::update_addressbook::Addrtype::Home,
            }),
        city: args.city.clone(),
        country: args.country.clone(),
        is_valid: args.is_valid,
        people: args.people.clone(),
        person: args.person.as_ref().and_then(|s| serde_json::from_str::<crate::models::Person>(s).ok()).map(|p| Box::new(p)),
        state: args.state.clone(),
        street: args.street.clone(),
        };
    
    let resp = crate::apis::addressbook_api::addressbook_address_key_put(&ctx.api_client, req_body, &args.address_key).await?;
    Ok(())
}

