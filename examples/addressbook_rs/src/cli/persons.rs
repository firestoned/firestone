// Auto-generated CLI module - generated by firestone
use clap::{Parser, Subcommand};
use serde_json;
use std::sync::Arc;

use crate::apis::configuration::Configuration;

// Context for API client - similar to Python's ctx_obj
pub struct ApiContext {
    pub api_client: Arc<Configuration>,
}

#[derive(Subcommand, Debug)]
pub enum PersonsCommands {
    /// Create a new person in this collection, a new UUID key will be created
    Create(CreateArgs),
    /// List all persons in this collection
    List(ListArgs),
    /// Delete operation for persons
    Delete(DeleteArgs),
    /// Get a specific person from this collection
    Get(GetArgs),
    /// Put a new person in this collection, with the given UUId key
    Update(UpdateArgs),
    }

#[derive(Parser, Debug)]
pub struct CreateArgs {
/// The person's age
    #[arg(long)]
    pub age: Option<i64>,
    /// The person's first name
    #[arg(long)]
    pub first_name: Option<String>,
    /// The person's hobbies
    #[arg(long)]
    pub hobbies: Option<Vec<String>>,
    /// The person's last name
    #[arg(long)]
    pub last_name: Option<String>,
    /// A UUID associated to this person
    #[arg(long)]
    pub uuid: Option<String>,
    }

#[derive(Parser, Debug)]
pub struct ListArgs {
/// Filter by last name
    #[arg(long)]
    pub last_name: Option<String>,
    /// Limit the number of responses back
    #[arg(long)]
    pub limit: Option<i64>,
    /// The offset to start returning resources
    #[arg(long)]
    pub offset: Option<i64>,
    }

#[derive(Parser, Debug)]
pub struct DeleteArgs {
/// 
    pub uuid: String,
    }

#[derive(Parser, Debug)]
pub struct GetArgs {
/// Filter by last name
    #[arg(long)]
    pub last_name: Option<String>,
    /// 
    pub uuid: String,
    }

#[derive(Parser, Debug)]
pub struct UpdateArgs {
/// The person's age
    #[arg(long)]
    pub age: Option<i64>,
    /// The person's first name
    #[arg(long)]
    pub first_name: Option<String>,
    /// The person's hobbies
    #[arg(long)]
    pub hobbies: Option<Vec<String>>,
    /// The person's last name
    #[arg(long)]
    pub last_name: Option<String>,
    /// A UUID associated to this person
    pub uuid: String,
    }

pub async fn handle_persons_command(
    ctx: &ApiContext,
    cmd: &PersonsCommands,
) -> Result<(), Box<dyn std::error::Error>> {
    match cmd {
PersonsCommands::Create(args) => {
            handle_persons_post(ctx, args).await
        },
PersonsCommands::List(args) => {
            handle_persons_get(ctx, args).await
        },
PersonsCommands::Delete(args) => {
            handle_persons_uuid_delete(ctx, args).await
        },
PersonsCommands::Get(args) => {
            handle_persons_uuid_get(ctx, args).await
        },
PersonsCommands::Update(args) => {
            handle_persons_uuid_put(ctx, args).await
        },
}
}

async fn handle_persons_post(
    ctx: &ApiContext,
    args: &CreateArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build request body for create operation
    let req_body = crate::models::CreatePerson {
        age: args.age.map(|v| v as i32),
        first_name: args.first_name.clone(),
        hobbies: args.hobbies.clone(),
        last_name: args.last_name.clone(),
        uuid: args.uuid.as_ref().map(|s| Some(serde_json::Value::String(s.clone()))),
        };
    
    // Extract query parameters (limit, offset) if present
    let limit = None::<i32>;
    let offset = None::<i32>;
    let resp = crate::apis::persons_api::persons_post(&ctx.api_client, req_body, limit, offset).await?;
    Ok(())
}

async fn handle_persons_get(
    ctx: &ApiContext,
    args: &ListArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters - openapi-generator functions take individual Option parameters
    let last_name_param = args.last_name.as_ref().map(|s| s.as_str());
    let limit_param = None::<i32>;
    let offset_param = None::<i32>;
    let resp = crate::apis::persons_api::persons_get(&ctx.api_client, last_name_param, limit_param, offset_param).await?;
    // Output response as JSON
    let json_output = serde_json::to_string_pretty(&resp)?;
    println!("{}", json_output);
    Ok(())
}

async fn handle_persons_uuid_delete(
    ctx: &ApiContext,
    args: &DeleteArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters for instance operations
    let city_param = None::<&str>;
    // DELETE operations may return empty responses (204 No Content)
    // Handle gracefully without panicking on content type mismatches
    let resp_result = crate::apis::persons_api::persons_uuid_delete(&ctx.api_client, &args.uuid).await;
    match resp_result {
        Ok(data) => {
            // If we got JSON data, serialize and print it
            let json_output = serde_json::to_string_pretty(&data)?;
            println!("{}", json_output);
        },
        Err(crate::apis::Error::Serde(e)) => {
            // Check if this is a content type mismatch (empty response)
            let error_msg = e.to_string();
            if error_msg.contains("content type") || error_msg.contains("application/octet-stream") || error_msg.contains("cannot be converted") {
                // Empty response is OK for DELETE - operation succeeded
                // Output success JSON
                println!("{}", r#"{"status": "deleted"}"#);
            } else {
                // Real serialization error, propagate it
                return Err(Box::new(e));
            }
        },
        Err(e) => {
            // Other errors (network, HTTP errors, etc.) - propagate
            return Err(Box::new(e));
        }
    }
    Ok(())
}

async fn handle_persons_uuid_get(
    ctx: &ApiContext,
    args: &GetArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters for instance operations
    let last_name_param = args.last_name.as_ref().map(|s| s.as_str());
    let resp = crate::apis::persons_api::persons_uuid_get(&ctx.api_client, &args.uuid, last_name_param).await?;
    // Output response as JSON
    let json_output = serde_json::to_string_pretty(&resp)?;
    println!("{}", json_output);
    Ok(())
}

async fn handle_persons_uuid_put(
    ctx: &ApiContext,
    args: &UpdateArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build request body for update operation
    let req_body = crate::models::UpdatePerson {
        age: args.age.map(|v| v as i32),
        first_name: args.first_name.clone(),
        hobbies: args.hobbies.clone(),
        last_name: args.last_name.clone(),
        uuid: None,
        };
    
    let resp = crate::apis::persons_api::persons_uuid_put(&ctx.api_client, req_body, &args.uuid).await?;
    Ok(())
}

