// Auto-generated CLI module - generated by firestone
use clap::{Parser, Subcommand};
use serde_json;
use std::sync::Arc;

use crate::apis::configuration::Configuration;

#[derive(clap::ValueEnum, Clone, Debug)]
enum PriorityEnum {
    HIGH,
    MEDIUM,
    LOW,
}
#[derive(clap::ValueEnum, Clone, Debug)]
enum StatusEnum {
    ACTIVE,
    INACTIVE,
    ARCHIVED,
}
#[derive(clap::ValueEnum, Clone, Debug)]
enum TypeEnum {
    PERSONAL,
    BUSINESS,
    EMERGENCY,
}
// Context for API client - similar to Python's ctx_obj
pub struct ApiContext {
    pub api_client: Arc<Configuration>,
}

#[derive(Subcommand, Debug)]
pub enum ContactsCommands {
    /// Create a new contact in this collection
    Create(CreateArgs),
    /// List all contacts in this collection
    List(ListArgs),
    /// Delete this contact from the collection
    Delete(DeleteArgs),
    /// Get a specific contact from this collection
    Get(GetArgs),
}

#[derive(Parser, Debug)]
pub struct CreateArgs {
    /// Contact categories (array of enums)
    #[arg(long)]
    pub categories: Vec<String>,
    /// The unique ID for this contact
    #[arg(long)]
    pub contact_id: String,
    /// Contact email address
    #[arg(long)]
    pub email: Option<String>,
    /// The contact's name
    #[arg(long)]
    pub name: String,
    /// Optional notes (array of strings, not enums)
    #[arg(long)]
    pub notes: Option<Vec<String>>,
    /// Contact priority level (required enum)
    #[arg(long, value_enum)]
    pub priority: PriorityEnum,
    /// The status of the contact (optional enum with default)
    #[arg(long, value_enum)]
    #[arg(default_value = "active")]
    pub status: StatusEnum,
    /// The contact type (optional enum, tests Rust keyword escaping)
    #[arg(long, value_enum)]
    pub r#type: Option<TypeEnum>,
}

#[derive(Parser, Debug)]
pub struct ListArgs {
    /// Limit the number of responses back
    #[arg(long)]
    pub limit: Option<i64>,
    /// The offset to start returning resources
    #[arg(long)]
    pub offset: Option<i64>,
}

#[derive(Parser, Debug)]
pub struct DeleteArgs {
    ///
    pub contact_id: String,
}

#[derive(Parser, Debug)]
pub struct GetArgs {
    ///
    pub contact_id: String,
}

pub async fn handle_contacts_command(
    ctx: &ApiContext,
    cmd: &ContactsCommands,
) -> Result<(), Box<dyn std::error::Error>> {
    match cmd {
        ContactsCommands::Create(args) => handle_contacts_post(ctx, args).await,
        ContactsCommands::List(args) => handle_contacts_get(ctx, args).await,
        ContactsCommands::Delete(args) => handle_contacts_contact_id_delete(ctx, args).await,
        ContactsCommands::Get(args) => handle_contacts_contact_id_get(ctx, args).await,
    }
}

async fn handle_contacts_post(
    ctx: &ApiContext,
    args: &CreateArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build request body for create operation
    let req_body = crate::models::CreateContact {
        categories: args
            .categories
            .iter()
            .map(|s| match s.to_lowercase().as_str() {
                "family" => crate::models::create_contact::Categories::Family,
                "friend" => crate::models::create_contact::Categories::Friend,
                "colleague" => crate::models::create_contact::Categories::Colleague,
                "vendor" => crate::models::create_contact::Categories::Vendor,
                _ => panic!("Invalid enum value for categories: {}", s),
            })
            .collect(),
        contact_id: Some(serde_json::Value::String(args.contact_id.clone())),
        email: args.email.clone(),
        name: args.name.clone(),
        notes: args.notes.clone(),
        priority: match args.priority {
            PriorityEnum::HIGH => crate::models::create_contact::Priority::High,
            PriorityEnum::MEDIUM => crate::models::create_contact::Priority::Medium,
            PriorityEnum::LOW => crate::models::create_contact::Priority::Low,
        },
        status: Some(match args.status {
            StatusEnum::ACTIVE => crate::models::create_contact::Status::Active,
            StatusEnum::INACTIVE => crate::models::create_contact::Status::Inactive,
            StatusEnum::ARCHIVED => crate::models::create_contact::Status::Archived,
        }),
        r#type: args.r#type.as_ref().map(|e| match e {
            TypeEnum::PERSONAL => crate::models::create_contact::Type::Personal,
            TypeEnum::BUSINESS => crate::models::create_contact::Type::Business,
            TypeEnum::EMERGENCY => crate::models::create_contact::Type::Emergency,
        }),
    };

    // Extract query parameters (limit, offset) if present
    let limit = None::<i32>;
    let offset = None::<i32>;
    let resp =
        crate::apis::contacts_api::contacts_post(&ctx.api_client, req_body, limit, offset).await?;
    Ok(())
}

async fn handle_contacts_get(
    ctx: &ApiContext,
    args: &ListArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters - openapi-generator functions take individual Option parameters
    let limit_param = args.limit.map(|v| v as i32);
    let offset_param = args.offset.map(|v| v as i32);
    let resp =
        crate::apis::contacts_api::contacts_get(&ctx.api_client, limit_param, offset_param).await?;
    // Output response as JSON
    let json_output = serde_json::to_string_pretty(&resp)?;
    println!("{}", json_output);
    Ok(())
}

async fn handle_contacts_contact_id_delete(
    ctx: &ApiContext,
    args: &DeleteArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters for instance operations
    // DELETE operations may return empty responses (204 No Content)
    // Handle gracefully without panicking on content type mismatches
    let resp_result =
        crate::apis::contacts_api::contacts_contact_id_delete(&ctx.api_client, &args.contact_id)
            .await;
    match resp_result {
        Ok(data) => {
            // If we got JSON data, serialize and print it
            let json_output = serde_json::to_string_pretty(&data)?;
            println!("{}", json_output);
        }
        Err(crate::apis::Error::Serde(e)) => {
            // Check if this is a content type mismatch (empty response)
            let error_msg = e.to_string();
            if error_msg.contains("content type")
                || error_msg.contains("application/octet-stream")
                || error_msg.contains("cannot be converted")
            {
                // Empty response is OK for DELETE - operation succeeded
                // Output success JSON
                println!("{}", r#"{"status": "deleted"}"#);
            } else {
                // Real serialization error, propagate it
                return Err(Box::new(e));
            }
        }
        Err(e) => {
            // Other errors (network, HTTP errors, etc.) - propagate
            return Err(Box::new(e));
        }
    }
    Ok(())
}

async fn handle_contacts_contact_id_get(
    ctx: &ApiContext,
    args: &GetArgs,
) -> Result<(), Box<dyn std::error::Error>> {
    // Build query parameters for instance operations
    let resp =
        crate::apis::contacts_api::contacts_contact_id_get(&ctx.api_client, &args.contact_id)
            .await?;
    // Output response as JSON
    let json_output = serde_json::to_string_pretty(&resp)?;
    println!("{}", json_output);
    Ok(())
}
