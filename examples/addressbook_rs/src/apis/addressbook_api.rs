/*
 * Example person and addressbook API
 *
 * Example person and addressbook API
 *
 * The version of the OpenAPI document: 1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`addressbook_address_key_addrtype_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyAddrtypeDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_addrtype_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyAddrtypeGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_addrtype_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyAddrtypeHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_addrtype_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyAddrtypePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_city_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyCityDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_city_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyCityGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_city_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyCityHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_city_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyCityPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_country_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyCountryDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_country_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyCountryGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_country_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyCountryHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_country_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyCountryPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_is_valid_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyIsValidDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_is_valid_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyIsValidGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_is_valid_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyIsValidHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_is_valid_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyIsValidPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_people_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPeopleDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_people_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPeopleGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_people_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPeopleHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_people_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPeoplePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_person_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPersonDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_person_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPersonGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_person_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPersonHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_person_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPersonPatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_person_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPersonPostError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_state_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyStateDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_state_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyStateGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_state_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyStateHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_state_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyStatePutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_street_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyStreetDeleteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_street_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyStreetGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_street_head`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyStreetHeadError {
    DefaultResponse(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_address_key_street_put`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookAddressKeyStreetPutError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookGetError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`addressbook_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddressbookPostError {
    UnknownValue(serde_json::Value),
}

/// delete operation for /addressbook/{address_key}/addrtype
pub async fn addressbook_address_key_addrtype_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyAddrtypeDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/addrtype",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyAddrtypeDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// get operation for /addressbook/{address_key}/addrtype
pub async fn addressbook_address_key_addrtype_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    city: Option<&str>,
) -> Result<String, Error<AddressbookAddressKeyAddrtypeGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_city = city;

    let uri_str = format!(
        "{}/addressbook/{address_key}/addrtype",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyAddrtypeGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// head operation for /addressbook/{address_key}/addrtype
pub async fn addressbook_address_key_addrtype_head(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<(), Error<AddressbookAddressKeyAddrtypeHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/addrtype",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyAddrtypeHeadError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// put operation for /addressbook/{address_key}/addrtype
pub async fn addressbook_address_key_addrtype_put(
    configuration: &configuration::Configuration,
    body: &str,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyAddrtypePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/addrtype",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyAddrtypePutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// delete operation for /addressbook/{address_key}/city
pub async fn addressbook_address_key_city_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyCityDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/city",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyCityDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// get operation for /addressbook/{address_key}/city
pub async fn addressbook_address_key_city_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    city: Option<&str>,
) -> Result<String, Error<AddressbookAddressKeyCityGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_city = city;

    let uri_str = format!(
        "{}/addressbook/{address_key}/city",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyCityGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// head operation for /addressbook/{address_key}/city
pub async fn addressbook_address_key_city_head(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<(), Error<AddressbookAddressKeyCityHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/city",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyCityHeadError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// put operation for /addressbook/{address_key}/city
pub async fn addressbook_address_key_city_put(
    configuration: &configuration::Configuration,
    body: &str,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyCityPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/city",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyCityPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// delete operation for /addressbook/{address_key}/country
pub async fn addressbook_address_key_country_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyCountryDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/country",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyCountryDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// get operation for /addressbook/{address_key}/country
pub async fn addressbook_address_key_country_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    city: Option<&str>,
) -> Result<String, Error<AddressbookAddressKeyCountryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_city = city;

    let uri_str = format!(
        "{}/addressbook/{address_key}/country",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyCountryGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// head operation for /addressbook/{address_key}/country
pub async fn addressbook_address_key_country_head(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<(), Error<AddressbookAddressKeyCountryHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/country",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyCountryHeadError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// put operation for /addressbook/{address_key}/country
pub async fn addressbook_address_key_country_put(
    configuration: &configuration::Configuration,
    body: &str,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyCountryPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/country",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyCountryPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete an address from this addressbook.
pub async fn addressbook_address_key_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<models::Addressbook, Error<AddressbookAddressKeyDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Addressbook`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Addressbook`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a specific address from this addressbook.
pub async fn addressbook_address_key_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    city: Option<&str>,
) -> Result<models::Addressbook, Error<AddressbookAddressKeyGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_city = city;

    let uri_str = format!(
        "{}/addressbook/{address_key}",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Addressbook`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Addressbook`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Determine the existence and size of this address.
pub async fn addressbook_address_key_head(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<(), Error<AddressbookAddressKeyHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyHeadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// delete operation for /addressbook/{address_key}/is_valid
pub async fn addressbook_address_key_is_valid_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<bool, Error<AddressbookAddressKeyIsValidDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/is_valid",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyIsValidDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// get operation for /addressbook/{address_key}/is_valid
pub async fn addressbook_address_key_is_valid_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    city: Option<&str>,
) -> Result<bool, Error<AddressbookAddressKeyIsValidGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_city = city;

    let uri_str = format!(
        "{}/addressbook/{address_key}/is_valid",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyIsValidGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// head operation for /addressbook/{address_key}/is_valid
pub async fn addressbook_address_key_is_valid_head(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<(), Error<AddressbookAddressKeyIsValidHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/is_valid",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyIsValidHeadError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// put operation for /addressbook/{address_key}/is_valid
pub async fn addressbook_address_key_is_valid_put(
    configuration: &configuration::Configuration,
    body: bool,
    address_key: &str,
) -> Result<bool, Error<AddressbookAddressKeyIsValidPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/is_valid",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `bool`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `bool`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyIsValidPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// delete operation for /addressbook/{address_key}/people
pub async fn addressbook_address_key_people_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<Vec<String>, Error<AddressbookAddressKeyPeopleDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/people",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPeopleDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// get operation for /addressbook/{address_key}/people
pub async fn addressbook_address_key_people_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    city: Option<&str>,
) -> Result<Vec<String>, Error<AddressbookAddressKeyPeopleGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_city = city;

    let uri_str = format!(
        "{}/addressbook/{address_key}/people",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPeopleGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// head operation for /addressbook/{address_key}/people
pub async fn addressbook_address_key_people_head(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<(), Error<AddressbookAddressKeyPeopleHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/people",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPeopleHeadError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// put operation for /addressbook/{address_key}/people
pub async fn addressbook_address_key_people_put(
    configuration: &configuration::Configuration,
    request_body: Vec<String>,
    address_key: &str,
) -> Result<Vec<String>, Error<AddressbookAddressKeyPeoplePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_request_body = request_body;
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/people",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;String&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;String&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPeoplePutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// delete operation for /addressbook/{address_key}/person
pub async fn addressbook_address_key_person_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::Person, Error<AddressbookAddressKeyPersonDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!(
        "{}/addressbook/{address_key}/person",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Person`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Person`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPersonDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// get operation for /addressbook/{address_key}/person
pub async fn addressbook_address_key_person_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    last_name: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<Vec<models::Person>, Error<AddressbookAddressKeyPersonGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_last_name = last_name;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!(
        "{}/addressbook/{address_key}/person",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_last_name {
        req_builder = req_builder.query(&[("last_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Person&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Person&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPersonGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// head operation for /addressbook/{address_key}/person
pub async fn addressbook_address_key_person_head(
    configuration: &configuration::Configuration,
    address_key: &str,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<(), Error<AddressbookAddressKeyPersonHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!(
        "{}/addressbook/{address_key}/person",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPersonHeadError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// patch operation for /addressbook/{address_key}/person
pub async fn addressbook_address_key_person_patch(
    configuration: &configuration::Configuration,
    address_key: &str,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::Person, Error<AddressbookAddressKeyPersonPatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!(
        "{}/addressbook/{address_key}/person",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Person`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Person`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPersonPatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// post operation for /addressbook/{address_key}/person
pub async fn addressbook_address_key_person_post(
    configuration: &configuration::Configuration,
    create_person: models::CreatePerson,
    address_key: &str,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::CreatePerson, Error<AddressbookAddressKeyPersonPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_person = create_person;
    let p_path_address_key = address_key;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!(
        "{}/addressbook/{address_key}/person",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_person);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreatePerson`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreatePerson`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPersonPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update an existing address in this addressbook, with the given address key.
pub async fn addressbook_address_key_put(
    configuration: &configuration::Configuration,
    update_addressbook: models::UpdateAddressbook,
    address_key: &str,
) -> Result<models::UpdateAddressbook, Error<AddressbookAddressKeyPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_update_addressbook = update_addressbook;
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_update_addressbook);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateAddressbook`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateAddressbook`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyPutError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// delete operation for /addressbook/{address_key}/state
pub async fn addressbook_address_key_state_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyStateDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/state",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyStateDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// get operation for /addressbook/{address_key}/state
pub async fn addressbook_address_key_state_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    city: Option<&str>,
) -> Result<String, Error<AddressbookAddressKeyStateGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_city = city;

    let uri_str = format!(
        "{}/addressbook/{address_key}/state",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyStateGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// head operation for /addressbook/{address_key}/state
pub async fn addressbook_address_key_state_head(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<(), Error<AddressbookAddressKeyStateHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/state",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyStateHeadError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// put operation for /addressbook/{address_key}/state
pub async fn addressbook_address_key_state_put(
    configuration: &configuration::Configuration,
    body: &str,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyStatePutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/state",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyStatePutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// delete operation for /addressbook/{address_key}/street
pub async fn addressbook_address_key_street_delete(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyStreetDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/street",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyStreetDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// get operation for /addressbook/{address_key}/street
pub async fn addressbook_address_key_street_get(
    configuration: &configuration::Configuration,
    address_key: &str,
    city: Option<&str>,
) -> Result<String, Error<AddressbookAddressKeyStreetGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;
    let p_query_city = city;

    let uri_str = format!(
        "{}/addressbook/{address_key}/street",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyStreetGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// head operation for /addressbook/{address_key}/street
pub async fn addressbook_address_key_street_head(
    configuration: &configuration::Configuration,
    address_key: &str,
) -> Result<(), Error<AddressbookAddressKeyStreetHeadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/street",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::HEAD, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyStreetHeadError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// put operation for /addressbook/{address_key}/street
pub async fn addressbook_address_key_street_put(
    configuration: &configuration::Configuration,
    body: &str,
    address_key: &str,
) -> Result<String, Error<AddressbookAddressKeyStreetPutError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_body = body;
    let p_path_address_key = address_key;

    let uri_str = format!(
        "{}/addressbook/{address_key}/street",
        configuration.base_path,
        address_key = crate::apis::urlencode(p_path_address_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookAddressKeyStreetPutError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List all addresses in this addressbook.
pub async fn addressbook_get(
    configuration: &configuration::Configuration,
    city: Option<&str>,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<Vec<models::Addressbook>, Error<AddressbookGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_city = city;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/addressbook", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_city {
        req_builder = req_builder.query(&[("city", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Addressbook&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Addressbook&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a new address in this addressbook, a new address key will be created.
pub async fn addressbook_post(
    configuration: &configuration::Configuration,
    create_addressbook: models::CreateAddressbook,
    limit: Option<i32>,
    offset: Option<i32>,
) -> Result<models::CreateAddressbook, Error<AddressbookPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_create_addressbook = create_addressbook;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/addressbook", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_create_addressbook);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateAddressbook`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateAddressbook`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AddressbookPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
